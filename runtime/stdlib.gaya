(* Constants *)

true  :: 1
false :: 0

(* Basic math *)

math.add :: { x, y => x + y }

(* Utilities *)

ifelse :: { b, iftrue, iffalse =>
  cases
    given b   => iftrue()
    otherwise => iffalse()
  end
}

(* Strings *)

(* Return whether the provided string is empty or not. *)
string.isempty :: { s => string.length(s) == 0 }

(* Return the first character in a string, or unit if empty. *)
string.first :: { s =>
  cases
    given typeof(s) == "string" and not string.isempty(s) => s(0)
  end
}

(* Return the last character in a string, or unit if empty. *)
string.last :: { s =>
  cases
    given typeof(s) == "string" and not string.isempty(s) => s(string.length(s) - 1)
  end
}

(* Return whether a string s starts with the given pattern. *)
string.startswith :: { s, pattern =>
  cases
    given string.length(s) < string.length(pattern) => 0
    otherwise =>
      let i = 0 in
      let result = 1 in do
        while i < string.length(pattern) and result
          result <- s(i) == pattern(i)
          i <- i + 1
        end

        result
      end
  end
}

(* Return whether a string s ends with the given pattern. *)
string.endswith :: { s, pattern =>
  cases 
    given string.length(s) < string.length(pattern) => 0
    otherwise =>
      let i = string.length(s) - 1 in
      let j = string.length(pattern) - 1 in 
      let result = 1 in do
        while i >= 0 and j >= 0 and result
          result <- s(i) == pattern(j)
          i <- i - 1
          j <- j - 1
        end

        result
      end
  end
}

(* Return the index in s where the provided pattern starts, or unit if not found. *)
string.index :: { s, pattern =>
  cases 
    given string.length(s) < string.length(pattern) => unit
    otherwise =>
      let slen = string.length(s),
          plen = string.length(pattern),
          completeMatch = false, i = 0 in do
        while not completeMatch and i < slen - plen + 1 : i <- i + 1
          discard let j = 0, match = true in do
            while match and j < plen : j <- j + 1
              match <- s(i + j) == pattern(j)
            end

            completeMatch <- match
          end
        end

        ifelse(completeMatch, { => i - 1}, { => unit })
      end
  end
}

(* Return whether the provided pattern is contained in s. *)
string.contains :: { s, pattern => string.index(s, pattern) /= unit }

(* Return a substring of s from start to finish.

  If start < finish or start < 0 or finish > string.length(s), unit
  is returned instead.
*)
string.substring :: { s, start, finish =>
  cases
    given finish <= start or start < 0 or finish > string.length(s) => unit
    otherwise =>
      let result = "", i = start in do
        while i < finish : i <- i + 1
          result <- string.concat(result, s(i))
        end

        result
      end
  end
}

(* Splits a string on the given pattern and returns an array with the parts. *)
string.split :: { s, pattern =>
  cases 
    given not string.contains(s, pattern) => ()
    otherwise =>
      let result = (), i = 0, j = 0 in
      let unitToStr = { x => ifelse(x == unit, { => "" }, { => x }) } in 
      let nextPart = { =>
          s 
          |> string.substring(_, j, i) 
          |> unitToStr(_)
          |> array.push(result, _) 
        } in do
        while i < string.length(s)
          discard let ss = string.substring(s, i, string.length(s)) in
          cases 
            given string.index(ss, pattern) == 0 => do
              result <- nextPart()
              i <- i + string.length(pattern)
              j <- i
            end
            otherwise => perform i <- i + 1
          end
        end

        nextPart()
      end
  end
}

(* Return whether a string is a whitespace character. *)
string.iswhitespace :: { s => s == " " or s == "\n" or s == "\t" }

(* Trim leading and trailing whitespace from a string. *)
string.trim :: { s =>
  let start = 0, finish = string.length(s) - 1 in do
    while string.iswhitespace(s(start)) and start < string.length(s)
      start <- start + 1
    end
    
    while string.iswhitespace(s(finish)) and finish > start
      finish <- finish - 1
    end

    string.substring(s, start, finish + 1)
  end
}

(* Arrays *)

(* Return an array with the numbers from start to finish exclusive. *)
array.range :: { start, finish => do
    discard assert(typeof(start) == "number" and typeof(finish) == "number")
    let i = start, a = () in do
      while i < finish : i <- i + 1
        discard array.push(a, i)
      end

      a
    end
  end
}

(*
  Return a string that is the result of joining the elements of the provided
  array by the given separator.
*)
array.join :: { ary, sep => do
    discard assert(typeof(ary) == "array" and typeof(sep) == "string")
    let i = 0, result = "" in do
      while i < array.length(ary) : i <- i + 1
        result <- result |> string.concat(_, ary(i) |> tostring(_))
        discard cases 
          given i < array.length(ary) - 1 => 
            perform result <- result |> string.concat(_, sep)
        end
      end

      result
    end
  end
}

(* Sequences *)

(*
  Call the provided function for each element in the sequence, discarding
  the results.
 *)
seq.foreach :: { s, f => do
    discard s |> issequence(_) |> assert(_)
    let xs = tosequence(s), next = seq.next(xs) in perform
    while next /= unit : next <- seq.next(xs)
      discard f(next)
    end
  end
}

(* 
  Reduce the provided sequence according to the specified accumulator function,
  using the given initial element. Return the initial element if the sequence
  was empty.
 *)
seq.reduce :: { s, init, f => do
    discard s |> issequence(_) |> assert(_)
    let acc = init, xs = tosequence(s), next = seq.next(xs) in do
      while next /= unit : next <- seq.next(xs)
        acc <- f(acc, next)
      end

      acc
    end
  end
}

(*
  Return a new sequence that maps the given function over the elements of the
  provided sequence. 
*)
seq.map :: { s, func => do
    discard s |> issequence(_) |> assert(_)
    let xs = tosequence(s) in seq.make { =>
      let next = seq.next(xs) in
      cases 
        given next /= unit => func(next)
      end
    }
  end
}

(*
  Return a new sequence that filters out elements for which the provided
  predicate function returns false.
*)
seq.filter :: { xs, func => do
    discard xs |> issequence(_) |> assert(_)
    let xs = tosequence(xs) in seq.make { => 
      let x = seq.next(xs) in do
        while x /= unit and not func(x)
          x <- seq.next(xs)
        end

        x
      end
    }
  end
}

(*
  Return a new sequence that applies the provided function to the elements of
  the given sequence in a pairwise manner.
*)
seq.zip :: { xs, ys, func => do
    discard xs |> issequence(_) |> assert(_)
    discard ys |> issequence(_) |> assert(_)
    let xs = tosequence(xs), ys = tosequence(ys) in seq.make { =>
      let x = seq.next(xs), y = seq.next(ys) in
      cases 
        given x /= unit and y /= unit => func(x, y)
      end
    }
  end
}

(*
  Return a sequence that takes elements from the input sequences as long as
  they satisfy the given predicate.
*)
seq.takewhile :: { xs, pred => do
    discard xs |> issequence(_) |> assert(_)
    let xs = tosequence(xs) in seq.make { =>
      let x = seq.next(xs) in
      cases
        given pred(x) => x
      end
    }
  end
}

(* Return a sequence that takes the first n elements of the provided one. *)
seq.take :: { xs, n => do
    discard xs |> issequence(_) |> assert(_)
    let xs = tosequence(xs), i = 0 in seq.make { =>
      cases
        given i < n => do
          i <- i + 1
          seq.next(xs)
        end
      end
    }
  end
}

(*
  Return a sequence that drops elements from the input sequence as long as they
  satisfy the given predicate.
*)
seq.dropwhile :: { xs, pred => do
    discard xs |> issequence(_) |> assert(_)
    let xs = tosequence(xs), predicateFailed = false in seq.make { =>
      let x = seq.next(xs) in do
        while x /= unit and not predicateFailed
          discard cases
            given pred(x) => perform x <- seq.next(xs) 
            otherwise     => perform predicateFailed <- true
          end
        end

        x
      end
    }
  end
}

(* Return a new sequence that drops the first n elements of the provided one. *)
seq.drop :: { xs, n => do
    discard xs |> issequence(_) |> assert(_)
    let xs = tosequence(xs), i = 1, x = seq.next(xs) in seq.make { => do
        while i < n : i <- i + 1
          x <- seq.next(xs)
        end
        
        seq.next(xs)
      end
    }
  end
}

(* Return an array with the elements of the provided sequence. *)
seq.toarray :: { xs => do
    discard xs |> issequence(_) |> assert(_)
    let xs = tosequence(xs), x = seq.next(xs), ary = () in do
      while x /= unit : x <- seq.next(xs)
        discard array.push(ary, x)
      end

      ary
    end
  end
}

(*
  Return a string with the elements of the provided sequence. 

  `tostring` is called on every element of the sequence to transform it to a
  string.
*)
seq.tostring :: { xs => do
    discard xs |> issequence(_) |> assert(_)
    let xs = tosequence(xs), x = seq.next(xs), s = "" in do
      while x /= unit : x <- seq.next(xs)
        discard x |> tostring(_) |> string.concat(s, _)
      end

      s
    end
  end
}


(* Dictionaries *)

(* Return a sequence over the keys of the provided dictionary. *)
dict.keys :: { dict => dict |> seq.map(_) { xs => xs(0) } }

(* Return a sequence over the values of the provided dictionary. *)
dict.values :: { dict => dict |> seq.map(_) { xs => xs(1) } }
