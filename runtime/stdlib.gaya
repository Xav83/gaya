(* Constants *)

true  :: 1
false :: 0

(* Utilities *)

ifelse :: { b, iftrue, iffalse =>
  cases
    given b   => iftrue()
    otherwise => iffalse()
  end
}

(* Strings *)

(* Return whether the provided string is empty or not. *)
string.empty :: { s => string.length(s) == 0 }

(* Return the first character in a string, or unit if empty. *)
string.first :: { s =>
  cases
    given typeof(s) == "string" and not string.empty(s) => s(0)
  end
}

(* Return the last character in a string, or unit if empty. *)
string.last :: { s =>
  cases
    given typeof(s) == "string" and not string.empty(s) => s(string.length(s) - 1)
  end
}

(* Return whether a string s starts with the given pattern. *)
string.startswith :: { s, pattern =>
  cases
    given string.length(s) < string.length(pattern) => 0
    otherwise =>
      let i = 0 in
      let result = 1 in do
        while i < string.length(pattern) and result
          result <- s(i) == pattern(i)
          i <- i + 1
        end

        result
      end
  end
}

(* Return whether a string s ends with the given pattern. *)
string.endswith :: { s, pattern =>
  cases 
    given string.length(s) < string.length(pattern) => 0
    otherwise =>
      let i = string.length(s) - 1 in
      let j = string.length(pattern) - 1 in 
      let result = 1 in do
        while i >= 0 and j >= 0 and result
          result <- s(i) == pattern(j)
          i <- i - 1
          j <- j - 1
        end

        result
      end
  end
}

(* Return the index in s where the provided pattern starts, or unit if not found. *)
string.index :: { s, pattern =>
  cases 
    given string.length(s) < string.length(pattern) => unit
    otherwise =>
      let completeMatch = false in
      let i = 0 in do
        while not completeMatch and i < string.length(s) - string.length(pattern) + 1
          discard let j = 0 in
          let match = true in do 
            while match and j < string.length(pattern)
              match <- s(i + j) == pattern(j)
              j <- j + 1
            end

            completeMatch <- match
          end

          i <- i + 1
        end

        ifelse(completeMatch, { => i - 1}, { => unit })
      end
  end
}

(* Return whether the provided pattern is contained in s. *)
string.contains :: { s, pattern => string.index(s, pattern) /= unit }

(* Return a substring of s from start to finish.

  If start < finish or start < 0 or finish > string.length(s), unit
  is returned instead.
*)
string.substring :: { s, start, finish =>
  cases
    given finish <= start or start < 0 or finish > string.length(s) => unit
    otherwise =>
      let result = "" in
      let i = start in do
        while i < finish
          result <- string.concat(result, s(i))
          i <- i + 1
        end

        result
      end
  end
}

(* Splits a string on the given pattern and returns an array with the parts. *)
string.split :: { s, pattern =>
  cases 
    given not string.contains(s, pattern) => ()
    otherwise =>
      let result = () in
      let i = 0 in 
      let j = 0 in 
      let unitToStr = { x => ifelse(x == unit, { => "" }, { => x }) } in do
        while i < string.length(s)
          discard let ss = string.substring(s, i, string.length(s)) in
          cases 
            given string.index(ss, pattern) == 0 => do
              result <- array.push(result, unitToStr(string.substring(s, j, i)))
              i <- i + string.length(pattern)
              j <- i
            end
            otherwise => perform i <- i + 1
          end
        end

        array.push(result, unitToStr(string.substring(s, j, i)))
      end
  end
}

(* Return whether a string is a whitespace character. *)
string.iswhitespace :: { s => s == " " or s == "\n" or s == "\t" }

(* Trim leading and trailing whitespace from a string. *)
string.trim :: { s =>
  let start = 0 in
  let finish = string.length(s) - 1 in do
    while string.iswhitespace(s(start)) and start < string.length(s)
      start <- start + 1
    end
    
    while string.iswhitespace(s(finish)) and finish > start
      finish <- finish - 1
    end

    string.substring(s, start, finish + 1)
  end
}
